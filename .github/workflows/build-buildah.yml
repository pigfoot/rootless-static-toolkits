name: Build Buildah

on:
  # Manual trigger with version input
  workflow_dispatch:
    inputs:
      version:
        description: 'Buildah version to build (leave empty for latest from GitHub)'
        required: false
        type: string
        default: ''
      architecture:
        description: 'Target architecture'
        required: false
        type: choice
        options:
          - amd64
          - arm64
          - both
        default: both
      variant:
        description: 'Build variant (standalone/default/full or all)'
        required: false
        type: choice
        options:
          - standalone
          - default
          - full
          - all
        default: all

  # Called by check-releases workflow
  workflow_call:
    inputs:
      version:
        description: 'Buildah version to build'
        required: true
        type: string

# Ensure only one build runs at a time per version
concurrency:
  group: build-buildah-${{ inputs.version }}
  cancel-in-progress: false

permissions:
  contents: write
  id-token: write  # Required for cosign OIDC

jobs:
  validate:
    name: Validate version
    runs-on: ubuntu-latest
    steps:
      - name: Validate semver pattern
        env:
          VERSION: ${{ inputs.version }}
        run: |
          # Semver pattern: v1.2.3 or v1.2 or 1.2.3 or 1.2
          SEMVER_PATTERN='^v?[0-9]+\.[0-9]+(\.[0-9]+)?$'

          if [[ ! "$VERSION" =~ $SEMVER_PATTERN ]]; then
            echo "Error: Invalid version format '$VERSION'"
            echo "Expected format: v1.2.3 or v1.2 or 1.2.3 or 1.2"
            exit 1
          fi

          echo "‚úì Version '$VERSION' is valid"

  build:
    name: Build buildah-${{ matrix.libc }}-${{ matrix.variant }}-${{ matrix.arch }}
    needs: validate
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        arch: [amd64, arm64]
        variant: [standalone, default, full]
        libc: [static, glibc]
        include:
          - arch: amd64
            runner: ubuntu-24.04
          - arch: arm64
            runner: ubuntu-24.04-arm
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Install podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman

      - name: Pull container image
        run: podman pull docker.io/ubuntu:latest

      - name: Create build directory
        run: mkdir -p build

      - name: Run build and package in container
        env:
          VERSION: ${{ inputs.version }}
          TOOL: buildah
          ARCH: ${{ matrix.arch }}
          VARIANT: ${{ matrix.variant }}
          LIBC: ${{ matrix.libc }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Record build start time (NFR-005: build duration < 30 minutes)
          BUILD_START=$(date +%s)
          echo "Build started at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"

          podman run --rm \
            -v ./scripts:/workspace/scripts:ro,z \
            -v ./build:/workspace/build:rw,z \
            -e VERSION=$VERSION \
            -e TOOL=$TOOL \
            -e ARCH=$ARCH \
            -e VARIANT=$VARIANT \
            -e LIBC=$LIBC \
            -e GITHUB_TOKEN=$GITHUB_TOKEN \
            docker.io/ubuntu:latest \
            bash -c "
              source /workspace/scripts/container/setup-build-env.sh && \
              /workspace/scripts/build-tool.sh $TOOL $ARCH $VARIANT $LIBC && \
              /workspace/scripts/package.sh $TOOL $ARCH $LIBC $VARIANT $VERSION
            "

          # Calculate and validate build duration
          BUILD_END=$(date +%s)
          BUILD_DURATION=$((BUILD_END - BUILD_START))
          BUILD_MINUTES=$((BUILD_DURATION / 60))
          BUILD_SECONDS=$((BUILD_DURATION % 60))

          echo "Build completed at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          echo "Build duration: ${BUILD_MINUTES}m ${BUILD_SECONDS}s"

          # Validate build time < 30 minutes (1800 seconds)
          if [[ $BUILD_DURATION -ge 1800 ]]; then
            echo "‚ùå Build time exceeded 30 minutes limit (NFR-005)"
            echo "Actual: ${BUILD_MINUTES}m ${BUILD_SECONDS}s, Limit: 30m"
            exit 1
          else
            echo "‚úÖ Build time within limit: ${BUILD_MINUTES}m ${BUILD_SECONDS}s < 30m"
          fi

      - name: Verify linking
        env:
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          # Determine install directory based on LIBC variant
          if [[ "$LIBC" == "glibc" ]]; then
            INSTALL_DIR="build/buildah-${ARCH}-glibc/install/bin/"
          else
            INSTALL_DIR="build/buildah-${ARCH}/install/bin/"
          fi

          echo "Checking directory: $INSTALL_DIR"
          ls -la "$INSTALL_DIR" || {
            echo "Error: Directory $INSTALL_DIR not found"
            exit 1
          }

          found_binary=false
          for binary in "$INSTALL_DIR"/*; do
            # Skip if glob didn't match any files (bash returns the pattern itself)
            if [[ ! -f "$binary" ]]; then
              echo "Skipping non-file: $binary"
              continue
            fi

            found_binary=true
            echo "Checking: $binary"
            output=$(ldd "$binary" 2>&1 || true)

            if [[ "$LIBC" == "glibc" ]]; then
              # For glibc variant: allow only glibc dependencies
              if echo "$output" | grep -q "not a dynamic executable\|statically linked"; then
                echo "‚úì $binary is statically linked (even better than glibc-dynamic)"
              elif echo "$output" | grep -E "libc\.so\.6|libm\.so\.6|libresolv\.so\.2|libgcc_s\.so\.1|linux-vdso\.so\.1|ld-linux" | grep -v -E "libstdc\+\+|libcap|libglib" >/dev/null; then
                echo "‚úì $binary uses glibc dynamic linking (only glibc dependencies allowed)"
                # Verify no forbidden libraries
                if echo "$output" | grep -E "libstdc\+\+\.so|libcap\.so|libglib|libsystemd\.so" >/dev/null; then
                  echo "‚úó $binary has forbidden dynamic dependencies:"
                  echo "$output"
                  exit 1
                fi
              else
                echo "‚úó $binary linking verification failed:"
                echo "$output"
                exit 1
              fi
            else
              # For static variant: must be fully static
              if echo "$output" | grep -q "not a dynamic executable\|statically linked"; then
                echo "‚úì $binary is statically linked"
              else
                echo "‚úó $binary is NOT statically linked:"
                echo "$output"
                exit 1
              fi
            fi
          done

          if [[ "$found_binary" == "false" ]]; then
            echo "Error: No binaries found in $INSTALL_DIR"
            exit 1
          fi

      - name: Validate artifact sizes
        env:
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          echo "=== Validating artifact sizes ==="

          # Determine install directory based on LIBC variant
          if [[ "$LIBC" == "glibc" ]]; then
            INSTALL_DIR="build/buildah-${ARCH}-glibc/install/bin/"
          else
            INSTALL_DIR="build/buildah-${ARCH}/install/bin/"
          fi

          # NFR-002: Individual binaries < 50MB (52428800 bytes)
          echo "Checking individual binary sizes (must be < 50MB)..."
          for binary in "$INSTALL_DIR"/*; do
            if [[ ! -f "$binary" ]]; then
              continue
            fi

            size=$(stat -c%s "$binary" 2>/dev/null || stat -f%z "$binary" 2>/dev/null)
            size_mb=$((size / 1048576))

            if [[ $size -ge 52428800 ]]; then
              echo "‚ùå Binary size exceeded 50MB limit (NFR-002)"
              echo "  File: $(basename "$binary")"
              echo "  Size: ${size_mb}MB"
              exit 1
            else
              echo "  ‚úÖ $(basename "$binary"): ${size_mb}MB < 50MB"
            fi
          done

          echo ""
          echo "‚úÖ All artifact sizes within limits"

      - name: Test buildah binary
        env:
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
        run: |
          echo "Testing buildah binary on native ${{ matrix.arch }} runner..."

          # Determine install directory based on LIBC variant
          if [[ "$LIBC" == "glibc" ]]; then
            INSTALL_DIR="build/buildah-${ARCH}-glibc/install/bin/"
          else
            INSTALL_DIR="build/buildah-${ARCH}/install/bin/"
          fi

          "$INSTALL_DIR/buildah" --version
          echo "‚úì buildah binary works correctly"

      - name: Set tarball name
        id: tarball
        env:
          VARIANT: ${{ matrix.variant }}
          ARCH: ${{ matrix.arch }}
          LIBC: ${{ matrix.libc }}
          VERSION: ${{ inputs.version }}
        run: |
          # Tarball naming matches package.sh: {tool}-{version}-linux-{arch}-{libc}[-{variant}].tar.zst
          if [[ "$VARIANT" == "default" ]]; then
            TARBALL_NAME="buildah-${VERSION}-linux-${ARCH}-${LIBC}.tar.zst"
          else
            TARBALL_NAME="buildah-${VERSION}-linux-${ARCH}-${LIBC}-${VARIANT}.tar.zst"
          fi
          echo "name=$TARBALL_NAME" >> $GITHUB_OUTPUT

      - name: Upload artifacts
        uses: actions/upload-artifact@v5
        with:
          name: buildah-${{ matrix.libc }}-${{ matrix.variant }}-${{ matrix.arch }}
          path: |
            build/${{ steps.tarball.outputs.name }}
          retention-days: 7

  release:
    name: Create GitHub Release
    needs: build
    if: success()  # Only create release if all matrix builds succeeded
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Download buildah artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: buildah-*
          path: artifacts/

      - name: Consolidate artifacts
        run: |
          mkdir -p release/
          find artifacts/ -type f -name "buildah-*.tar.zst" -exec cp {} release/ \;
          ls -lh release/

      - name: Setup cosign
        uses: sigstore/cosign-installer@v4.0.0

      - name: Generate checksums and sign artifacts
        run: |
          chmod +x scripts/sign-release.sh
          scripts/sign-release.sh release/

      - name: Create Release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ inputs.version }}
        run: |
          TAG="buildah-${VERSION}"

          # Create release notes
          cat > /tmp/release-notes.md <<'NOTES'
          Static and glibc-dynamic binaries for buildah built with Clang + mimalloc (containerized build)

          **ARCHITECTURES**
            - linux/amd64
            - linux/arm64

          **LIBC VARIANTS**
            - `*-static.tar.zst`: Fully static (musl), zero runtime dependencies (‚≠ê RECOMMENDED for maximum portability)
            - `*-glibc.tar.zst`: Hybrid static (glibc-dynamic), requires glibc 2.34+ (Ubuntu 22.04+, Debian 12+, RHEL 9+)

          **PACKAGE VARIANTS**
            - `buildah-{version}-linux-{arch}-{libc}.tar.zst`: Default with crun + conmon + configs (‚≠ê RECOMMENDED for most users)
            - `buildah-{version}-linux-{arch}-{libc}-standalone.tar.zst`: Binary only (‚ö†Ô∏è NOT RECOMMENDED - requires system runc ‚â•1.1.11 + latest conmon)
            - `buildah-{version}-linux-{arch}-{libc}-full.tar.zst`: Complete build stack with fuse-overlayfs for rootless overlay mounts

          **COMPATIBILITY WARNINGS**
            - `standalone` requires compatible system packages (most Ubuntu versions have outdated runc/conmon)
            - `default` and `full` include all required runtimes - work on any Linux distribution

          **INSTALLATION**

          **Option A: Standalone variant (single binary)**
          ```bash
          # Download and extract (static variant recommended)
          curl -fsSL -O https://github.com/${{ github.repository }}/releases/download/buildah-${{ inputs.version }}/buildah-${{ inputs.version }}-linux-amd64-static-standalone.tar.zst
          tar -xf buildah-${{ inputs.version }}-linux-amd64-static-standalone.tar.zst
          cd buildah-${{ inputs.version }}

          # Run directly or copy to your preferred location
          ./buildah --version
          cp buildah ~/.local/bin/  # or /usr/local/bin with sudo
          ```

          **Option B: Default/Full variant (recommended)**
          ```bash
          # Download tarball for your architecture (static variant recommended)
          curl -fsSL -O https://github.com/${{ github.repository }}/releases/download/buildah-${{ inputs.version }}/buildah-${{ inputs.version }}-linux-amd64-static.tar.zst

          # Extract
          tar -xf buildah-${{ inputs.version }}-linux-amd64-static.tar.zst
          cd buildah-${{ inputs.version }}

          # Install system-wide
          sudo cp -r usr/* /usr/
          sudo cp -r etc/* /etc/

          # Or use from current directory
          export PATH=$PWD/usr/local/bin:$PATH
          buildah --version
          ```

          **For glibc variant** (requires glibc 2.34+):
          Replace `-static.tar.zst` with `-glibc.tar.zst` in the download URL.

          **VERIFICATION**

          All tarballs include SHA256 checksums and cosign signatures (keyless OIDC).

          Verify checksum:
          ```bash
          sha256sum -c checksums.txt --ignore-missing
          ```

          Verify cosign signature (example for default static variant):
          ```bash
          # Replace VERSION with actual version (e.g., v1.38.0)
          cosign verify-blob \
            --bundle=buildah-VERSION-linux-amd64-static.tar.zst.bundle \
            --certificate-identity-regexp='https://github.com/.*' \
            --certificate-oidc-issuer='https://token.actions.githubusercontent.com' \
            buildah-VERSION-linux-amd64-static.tar.zst
          ```

          **BUILD DETAILS**
            - Built inside docker.io/ubuntu:latest container using podman
            - Compiler: Clang with musl target + mimalloc allocator
            - Workflow ${{ github.workflow }}
            - Run ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          NOTES

          # Create or update release
          if gh release view "$TAG" &>/dev/null; then
            echo "Release $TAG already exists, uploading additional assets..."
            gh release upload "$TAG" release/* --clobber
          else
            echo "Creating new release $TAG..."
            gh release create "$TAG" \
              --title "Buildah ${VERSION}" \
              --notes-file /tmp/release-notes.md \
              release/*
          fi

      - name: Release Summary
        env:
          VERSION: ${{ inputs.version }}
        run: |
          echo "### üöÄ Release Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version**: buildah-${VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Artifacts**:" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          ls -lh release/ >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Download**: https://github.com/${{ github.repository }}/releases/tag/buildah-${VERSION}" >> $GITHUB_STEP_SUMMARY
